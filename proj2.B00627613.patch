diff -Nur xv6-cs550-2016,1s-p1-baseline/call100.c xv6-cs550-2016,1s-p2-working/call100.c
--- xv6-cs550-2016,1s-p1-baseline/call100.c	1969-12-31 19:00:00.000000000 -0500
+++ xv6-cs550-2016,1s-p2-working/call100.c	2016-03-08 20:42:14.000000000 -0500
@@ -0,0 +1,82 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+#include "date.h"
+#include "syscall.h"
+#include "traps.h"
+
+
+int
+main(int argc, char *argv[])
+{
+
+	int d =0;
+  if (argc > 1)
+  	printf(1,"Too many arguments!\n");
+  else
+  {
+  d=ls_call01();
+  printf(1,"Call %d\n", d);
+ d=ls_call02();
+  printf(1,"Call %d\n", d);
+  d=ls_call03();
+  printf(1,"Call %d\n", d);
+  d=ls_call04();
+  printf(1,"Call %d\n", d);
+  d=ls_call05();
+  printf(1,"Call %d\n", d);
+  d=ls_call06();
+  printf(1,"Call %d\n", d);
+ d=ls_call07();
+  printf(1,"Call %d\n", d);
+ d=ls_call07();
+ printf(1,"Call %d\n", d);  
+ d=ls_call08();
+  printf(1,"Call %d\n", d);
+ d=ls_call09();
+  printf(1,"Call %d\n", d);
+ d=ls_call10();
+  printf(1,"Call %d\n", d);
+ d=ls_call11();
+  printf(1,"Call %d\n", d);
+ d=ls_call12();
+  printf(1,"Call %d\n", d);
+ d=ls_call13();
+  printf(1,"Call %d\n", d);
+ d=ls_call14();
+  printf(1,"Call %d\n", d);
+ d=ls_call15();
+  printf(1,"Call %d\n", d);
+ d=ls_call16();
+  printf(1,"Call %d\n", d);
+ d=ls_call17();
+  printf(1,"Call %d\n", d);
+ d=ls_call18();
+  printf(1,"Call %d\n", d);
+ d=ls_call19();
+  printf(1,"Call %d\n", d);
+ d=ls_call20();
+  printf(1,"Call %d\n", d);
+ d=ls_call21();
+  printf(1,"Call %d\n", d);
+ d=ls_call22();
+  printf(1,"Call %d\n", d);
+ d=ls_call23();
+  printf(1,"Call %d\n", d);
+ d=ls_call24();
+  printf(1,"Call %d\n", d);
+ d=ls_call25();
+  printf(1,"Call %d\n", d);
+ d=ls_call26();
+  printf(1,"Call %d\n", d);
+ d=ls_call27();
+  printf(1,"Call %d\n", d);
+ d=ls_call28();
+  printf(1,"Call %d\n", d);
+ d=ls_call29();
+  printf(1,"Call %d\n", d);
+ d=ls_call30();
+  printf(1,"Call %d\n", d);
+ }
+  exit(); 
+}
diff -Nur xv6-cs550-2016,1s-p1-baseline/cs550_syscall.c xv6-cs550-2016,1s-p2-working/cs550_syscall.c
--- xv6-cs550-2016,1s-p1-baseline/cs550_syscall.c	1969-12-31 19:00:00.000000000 -0500
+++ xv6-cs550-2016,1s-p2-working/cs550_syscall.c	2016-03-08 22:39:33.000000000 -0500
@@ -0,0 +1,223 @@
+#include "types.h"
+#include "defs.h"
+#include "param.h"
+#include "memlayout.h"
+#include "mmu.h"
+#include "proc.h"
+#include "x86.h"
+#include "syscall.h"
+
+// User code makes a system call with INT T_SYSCALL.
+// System call number in %eax.
+// Arguments on the stack, from the user call to the C
+// library system call function. The saved user %esp points
+// to a saved program counter, and then the first argument.
+
+// Fetch the int at addr from the current process.
+int
+fetchint(uint addr, int *ip)
+{
+  if(addr >= proc->sz || addr+4 > proc->sz)
+    return -1;
+  *ip = *(int*)(addr);
+  return 0;
+}
+
+// Fetch the nul-terminated string at addr from the current process.
+// Doesn't actually copy the string - just sets *pp to point at it.
+// Returns length of string, not including nul.
+int
+fetchstr(uint addr, char **pp)
+{
+  char *s, *ep;
+
+  if(addr >= proc->sz)
+    return -1;
+  *pp = (char*)addr;
+  ep = (char*)proc->sz;
+  for(s = *pp; s < ep; s++)
+    if(*s == 0)
+      return s - *pp;
+  return -1;
+}
+
+// Fetch the nth 32-bit system call argument.
+int
+argint(int n, int *ip)
+{
+  return fetchint(proc->tf->esp + 4 + 4*n, ip);
+}
+
+// Fetch the nth word-sized system call argument as a pointer
+// to a block of memory of size n bytes.  Check that the pointer
+// lies within the process address space.
+int
+argptr(int n, char **pp, int size)
+{
+  int i;
+  
+  if(argint(n, &i) < 0)
+    return -1;
+  if((uint)i >= proc->sz || (uint)i+size > proc->sz)
+    return -1;
+  *pp = (char*)i;
+  return 0;
+}
+
+// Fetch the nth word-sized system call argument as a string pointer.
+// Check that the pointer is valid and the string is nul-terminated.
+// (There is no shared writable memory, so the string can't change
+// between this check and being used by the kernel.)
+int
+argstr(int n, char **pp)
+{
+  int addr;
+  if(argint(n, &addr) < 0)
+    return -1;
+  return fetchstr(addr, pp);
+}
+
+extern int sys_chdir(void);
+extern int sys_close(void);
+extern int sys_dup(void);
+extern int sys_exec(void);
+extern int sys_exit(void);
+extern int sys_fork(void);
+extern int sys_fstat(void);
+extern int sys_getpid(void);
+extern int sys_kill(void);
+extern int sys_link(void);
+extern int sys_mkdir(void);
+extern int sys_mknod(void);
+extern int sys_open(void);
+extern int sys_pipe(void);
+extern int sys_read(void);
+extern int sys_sbrk(void);
+extern int sys_sleep(void);
+extern int sys_unlink(void);
+extern int sys_wait(void);
+extern int sys_write(void);
+extern int sys_uptime(void);
+extern int sys_date(void);
+
+extern int sys_ls_call01(void);
+extern int sys_ls_call02(void);
+extern int sys_ls_call03(void);
+extern int sys_ls_call04(void);
+extern int sys_ls_call05(void);
+extern int sys_ls_call06(void);
+extern int sys_ls_call07(void);
+extern int sys_ls_call08(void);
+extern int sys_ls_call09(void);
+extern int sys_ls_call10(void);
+extern int sys_ls_call11(void);
+extern int sys_ls_call12(void);
+extern int sys_ls_call13(void);
+extern int sys_ls_call14(void);
+extern int sys_ls_call15(void);
+extern int sys_ls_call16(void);
+extern int sys_ls_call17(void);
+extern int sys_ls_call18(void);
+extern int sys_ls_call19(void);
+extern int sys_ls_call20(void);
+extern int sys_ls_call21(void);
+extern int sys_ls_call22(void);
+extern int sys_ls_call23(void);
+extern int sys_ls_call24(void);
+extern int sys_ls_call25(void);
+extern int sys_ls_call26(void);
+extern int sys_ls_call27(void);
+extern int sys_ls_call28(void);
+extern int sys_ls_call29(void);
+extern int sys_ls_call30(void);
+
+static int (*syscalls[])(void) = {
+[SYS_fork]    sys_fork,
+[SYS_exit]    sys_exit,
+[SYS_wait]    sys_wait,
+[SYS_pipe]    sys_pipe,
+[SYS_read]    sys_read,
+[SYS_kill]    sys_kill,
+[SYS_exec]    sys_exec,
+[SYS_fstat]   sys_fstat,
+[SYS_chdir]   sys_chdir,
+[SYS_dup]     sys_dup,
+[SYS_getpid]  sys_getpid,
+[SYS_sbrk]    sys_sbrk,
+[SYS_sleep]   sys_sleep,
+[SYS_uptime]  sys_uptime,
+[SYS_open]    sys_open,
+[SYS_write]   sys_write,
+[SYS_mknod]   sys_mknod,
+[SYS_unlink]  sys_unlink,
+[SYS_link]    sys_link,
+[SYS_mkdir]   sys_mkdir,
+[SYS_close]   sys_close,
+[SYS_date]    sys_date,
+};
+
+static int (*syscallls[])(void) = {
+sys_ls_call01,
+sys_ls_call02,
+sys_ls_call03,
+sys_ls_call04,
+sys_ls_call05,
+sys_ls_call06,
+sys_ls_call07,
+sys_ls_call08,
+sys_ls_call09,
+sys_ls_call10,
+sys_ls_call11,
+sys_ls_call12,
+sys_ls_call13,
+sys_ls_call14,
+sys_ls_call15,
+sys_ls_call16,
+sys_ls_call17,
+sys_ls_call18,
+sys_ls_call19,
+sys_ls_call20,
+sys_ls_call21,
+sys_ls_call22,
+sys_ls_call23,
+sys_ls_call24,
+sys_ls_call25,
+sys_ls_call26,
+sys_ls_call27,
+sys_ls_call28,
+sys_ls_call29,
+sys_ls_call30,
+};
+
+char lineartable[30][20] = {"ls_call01","ls_call02","ls_call03","ls_call04","ls_call05","ls_call06","ls_call07","ls_call08","ls_call09","ls_call10","ls_call11","ls_call12","ls_call13","ls_call14","ls_call15","ls_call16","ls_call17","ls_call18","ls_call19","ls_call20","ls_call21","ls_call22","ls_call23","ls_call24","ls_call25","ls_call26","ls_call27","ls_call28","ls_call29","ls_call30"};
+
+void
+syscall(void)
+{
+  int num;
+
+  num = proc->tf->eax;
+  if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
+    proc->tf->eax = syscalls[num]();
+  } else {
+    cprintf("%d %s: unknown sys call %d\n", proc->pid, proc->name, num);
+    proc->tf->eax = -1;
+  }
+}
+
+void
+syscall1(void)
+{
+
+  int p,i;
+  char *str1 = (char *) proc->tf->eax;
+  for(i=0;i<30;i++)
+  {
+    p = strncmp(str1,lineartable[i],strlen(str1));
+    if(p == 0)
+    {
+      proc->tf->eax = syscallls[i]();
+      break;
+    }
+  }
+}
diff -Nur xv6-cs550-2016,1s-p1-baseline/cs550_user.c xv6-cs550-2016,1s-p2-working/cs550_user.c
--- xv6-cs550-2016,1s-p1-baseline/cs550_user.c	1969-12-31 19:00:00.000000000 -0500
+++ xv6-cs550-2016,1s-p2-working/cs550_user.c	2016-03-08 21:22:43.000000000 -0500
@@ -0,0 +1,105 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+#include "date.h"
+#include "syscall.h"
+#include "traps.h"
+
+
+int
+main(int argc, char *argv[])
+{
+int i, t1, t2, t3, t4;    
+    int count =0;
+    if (argc > 1)
+        printf(1,"Error as argument exceeds the permissible limit!\n");
+    else
+    {
+	//----Date ----------------------------//
+	struct rtcdate r;
+  	date(&r);
+	printf(1,"Displaying Time \n");
+  	printf(1,"Year : %d | Month : %d | Day : %d | Hour : %d | Minute : %d | Second : %d \n", r.year,r.month,r.day,r.hour,r.minute,r.second);
+	
+	//----Linear ----------------------------//
+	printf(1,"Linear Hashing \n");
+        count=ls_call01();
+        printf(1,"%d\t", count);
+        count=ls_call02();
+        printf(1,"%d\t", count);
+        count=ls_call03();
+        printf(1,"%d\t", count);
+        count=ls_call04();
+        printf(1,"%d\t", count);
+        count=ls_call05();
+        printf(1,"%d\t", count);
+        count=ls_call06();
+        printf(1,"%d\n", count);
+        count=ls_call07();
+        printf(1,"%d\t", count);
+        count=ls_call08();
+        printf(1,"%d\t", count);
+        count=ls_call09();
+        printf(1,"%d\t", count);
+        count=ls_call10();
+        printf(1,"%d\t", count);
+        count=ls_call11();
+        printf(1,"%d\t", count);
+        count=ls_call12();
+        printf(1,"%d\n", count);
+        count=ls_call13();
+        printf(1,"%d\t", count);
+        count=ls_call14();
+        printf(1,"%d\t", count);
+        count=ls_call15();
+        printf(1,"%d\t", count);
+        count=ls_call16();
+        printf(1,"%d\t", count);
+        count=ls_call17();
+        printf(1,"%d\t", count);
+        count=ls_call18();
+        printf(1,"%d\n", count);
+        count=ls_call19();
+        printf(1,"%d\t", count);
+        count=ls_call20();
+        printf(1,"%d\t", count);
+        count=ls_call21();
+        printf(1,"%d\t", count);
+        count=ls_call22();
+        printf(1,"%d\t", count);
+        count=ls_call23();
+        printf(1,"%d\t", count);
+        count=ls_call24();
+        printf(1,"%d\n", count);
+        count=ls_call25();
+        printf(1,"%d\t", count);
+        count=ls_call26();
+        printf(1,"%d\t", count);
+        count=ls_call27();
+        printf(1,"%d\t", count);
+        count=ls_call28();
+        printf(1,"%d\t", count);
+        count=ls_call29();
+        printf(1,"%d\t", count);
+        count=ls_call30();
+        printf(1,"%d\t", count);
+
+} 	
+    t1=uptime();
+        for (i=0;i<1000000;i++)
+        {
+            ls_call01();
+        }
+
+        t2=uptime();
+        printf(1,"\n Time taken for 1000000 ls calls %d ticks \n", (t2-t1));
+        
+        t3=uptime();
+        for (i=0;i<1000000;i++)
+        {
+            getpid();
+        }
+        t4=uptime();
+        printf(1,"\n Time taken for 1000000 ls calls %d ticks \n", (t4-t3));
+    exit(); 
+}
diff -Nur xv6-cs550-2016,1s-p1-baseline/date.c xv6-cs550-2016,1s-p2-working/date.c
--- xv6-cs550-2016,1s-p1-baseline/date.c	1969-12-31 19:00:00.000000000 -0500
+++ xv6-cs550-2016,1s-p2-working/date.c	2016-03-08 13:44:17.000000000 -0500
@@ -0,0 +1,22 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+#include "date.h"
+#include "syscall.h"
+#include "traps.h"
+
+
+int
+main(int argc, char *argv[])
+{
+
+  struct rtcdate r;
+  if (argc > 1)
+  	printf(1,"Too many arguments!\n");
+  else
+  {
+  date(&r);
+  printf(1,"Year:%d, Month:%d,Day:%d Time %d-%d-%d\n", r.year,r.month,r.day, r.hour,r.minute, r.second);
+  }
+  exit(); 
+}
diff -Nur xv6-cs550-2016,1s-p1-baseline/defs.h xv6-cs550-2016,1s-p2-working/defs.h
--- xv6-cs550-2016,1s-p1-baseline/defs.h	2016-02-11 21:48:16.000000000 -0500
+++ xv6-cs550-2016,1s-p2-working/defs.h	2016-03-08 20:56:47.000000000 -0500
@@ -147,6 +147,7 @@
 int             fetchint(uint, int*);
 int             fetchstr(uint, char**);
 void            syscall(void);
+void            syscall1(void);
 
 // timer.c
 void            timerinit(void);
diff -Nur xv6-cs550-2016,1s-p1-baseline/defs.h.save.1 xv6-cs550-2016,1s-p2-working/defs.h.save.1
--- xv6-cs550-2016,1s-p1-baseline/defs.h.save.1	1969-12-31 19:00:00.000000000 -0500
+++ xv6-cs550-2016,1s-p2-working/defs.h.save.1	2016-03-04 19:26:17.000000000 -0500
@@ -0,0 +1,185 @@
+struct buf;
+struct context;
+struct file;
+struct inode;
+struct pipe;
+struct proc;
+struct rtcdate;
+struct spinlock;
+struct stat;
+struct superblock;
+
+// bio.c
+void            binit(void);
+struct buf*     bread(uint, uint);
+void            brelse(struct buf*);
+void            bwrite(struct buf*);
+
+// console.c
+void            consoleinit(void);
+void            cprintf(char*, ...);
+void            consoleintr(int(*)(void));
+void            panic(char*) __attribute__((noreturn));
+
+// exec.c
+int             exec(char*, char**);
+
+// file.c
+struct file*    filealloc(void);
+void            fileclose(struct file*);
+struct file*    filedup(struct file*);
+void            fileinit(void);
+int             fileread(struct file*, char*, int n);
+int             filestat(struct file*, struct stat*);
+int             filewrite(struct file*, char*, int n);
+
+// fs.c
+void            readsb(int dev, struct superblock *sb);
+int             dirlink(struct inode*, char*, uint);
+struct inode*   dirlookup(struct inode*, char*, uint*);
+struct inode*   ialloc(uint, short);
+struct inode*   idup(struct inode*);
+void            iinit(int dev);
+void            ilock(struct inode*);
+void            iput(struct inode*);
+void            iunlock(struct inode*);
+void            iunlockput(struct inode*);
+void            iupdate(struct inode*);
+int             namecmp(const char*, const char*);
+struct inode*   namei(char*);
+struct inode*   nameiparent(char*, char*);
+int             readi(struct inode*, char*, uint, uint);
+void            stati(struct inode*, struct stat*);
+int             writei(struct inode*, char*, uint, uint);
+
+// ide.c
+void            ideinit(void);
+void            ideintr(void);
+void            iderw(struct buf*);
+
+// ioapic.c
+void            ioapicenable(int irq, int cpu);
+extern uchar    ioapicid;
+void            ioapicinit(void);
+
+// kalloc.c
+char*           kalloc(void);
+void            kfree(char*);
+void            kinit1(void*, void*);
+void            kinit2(void*, void*);
+
+// kbd.c
+void            kbdintr(void);
+
+// lapic.c
+void            cmostime(struct rtcdate *r);
+int             cpunum(void);
+extern volatile uint*    lapic;
+void            lapiceoi(void);
+void            lapicinit(void);
+void            lapicstartap(uchar, uint);
+void            microdelay(int);
+
+// log.c
+void            initlog(int dev);
+void            log_write(struct buf*);
+void            begin_op();
+void            end_op();
+
+// mp.c
+extern int      ismp;
+int             mpbcpu(void);
+void            mpinit(void);
+void            mpstartthem(void);
+
+// picirq.c
+void            picenable(int);
+void            picinit(void);
+
+// pipe.c
+int             pipealloc(struct file**, struct file**);
+void            pipeclose(struct pipe*, int);
+int             piperead(struct pipe*, char*, int);
+int             pipewrite(struct pipe*, char*, int);
+
+//PAGEBREAK: 16
+// proc.c
+struct proc*    copyproc(struct proc*);
+void            exit(void);
+int             fork(void);
+int             growproc(int);
+int             kill(int);
+void            pinit(void);
+void            procdump(void);
+void            scheduler(void) __attribute__((noreturn));
+void            sched(void);
+void            sleep(void*, struct spinlock*);
+void            userinit(void);
+int             wait(void);
+void            wakeup(void*);
+void            yield(void);
+
+// swtch.S
+void            swtch(struct context**, struct context*);
+
+// spinlock.c
+void            acquire(struct spinlock*);
+void            getcallerpcs(void*, uint*);
+int             holding(struct spinlock*);
+void            initlock(struct spinlock*, char*);
+void            release(struct spinlock*);
+void            pushcli(void);
+void            popcli(void);
+
+// string.c
+int             memcmp(const void*, const void*, uint);
+void*           memmove(void*, const void*, uint);
+void*           memset(void*, int, uint);
+char*           safestrcpy(char*, const char*, int);
+int             strlen(const char*);
+int             strncmp(const char*, const char*, uint);
+char*           strncpy(char*, const char*, int);
+
+// syscall.c
+int             argint(int, int*);
+int             argptr(int, char**, int);
+int             argstr(int, char**);
+int             fetchint(uint, int*);
+int             fetchstr(uint, char**);
+void            syscall(void);
+
+// timer.c
+void            timerinit(void);
+
+// trap.c
+void            idtinit(void);
+extern uint     ticks;
+void            tvinit(void);
+extern struct spinlock tickslock;
+
+// uart.c
+void            uartinit(void);
+void            uartintr(void);
+void            uartputc(int);
+
+// vm.c
+void            seginit(void);
+void            kvmalloc(void);
+void            vmenable(void);
+pde_t*          setupkvm(void);
+char*           uva2ka(pde_t*, char*);
+int             allocuvm(pde_t*, uint, uint);
+int             deallocuvm(pde_t*, uint, uint);
+void            freevm(pde_t*);
+void            inituvm(pde_t*, char*, uint);
+int             loaduvm(pde_t*, char*, struct inode*, uint, uint);
+pde_t*          copyuvm(pde_t*, uint);
+void            switchuvm(struct proc*);
+void            switchkvm(void);
+int             copyout(pde_t*, uint, void*, uint);
+void            clearpteu(pde_t *pgdir, char *uva);
+
+// number of elements in fixed-size array
+#define NELEM(x) (sizeof(x)/sizeof((x)[0]))
+
+
diff -Nur xv6-cs550-2016,1s-p1-baseline/echo.c xv6-cs550-2016,1s-p2-working/echo.c
--- xv6-cs550-2016,1s-p1-baseline/echo.c	2016-02-11 21:48:16.000000000 -0500
+++ xv6-cs550-2016,1s-p2-working/echo.c	2016-03-04 16:04:13.000000000 -0500
@@ -1,13 +1,18 @@
 #include "types.h"
 #include "stat.h"
 #include "user.h"
+#include "date.h"
 
 int
 main(int argc, char *argv[])
 {
   int i;
+  struct rtcdate r;
+  date(&r);
+  printf(1,"%d, %d", r.year,r.month);
+
 
   for(i = 1; i < argc; i++)
-    printf(1, "%s%s", argv[i], i+1 < argc ? " " : "\n");
+  printf(1, "%s%s", argv[i], i+1 < argc ? " " : "\n");
   exit();
 }
diff -Nur xv6-cs550-2016,1s-p1-baseline/Makefile xv6-cs550-2016,1s-p2-working/Makefile
--- xv6-cs550-2016,1s-p1-baseline/Makefile	2016-02-14 16:56:28.000000000 -0500
+++ xv6-cs550-2016,1s-p2-working/Makefile	2016-03-08 22:46:03.000000000 -0500
@@ -27,7 +27,7 @@
 	uart.o\
 	vectors.o\
 	vm.o\
-
+	
 # Cross-compiling (e.g., on Mac OS X)
 # TOOLPREFIX = i386-jos-elf
 
@@ -52,6 +52,7 @@
 
 # If the makefile can't find QEMU, specify its path here
 # QEMU = qemu-system-i386
+QEMU=/home/kchiu/packages/linux-x86_64/bin/qemu-system-i386
 
 # Try to infer the correct QEMU
 ifndef QEMU
@@ -60,7 +61,8 @@
 	elif which qemu-system-i386 > /dev/null; \
 	then echo qemu-system-i386; exit; \
 	else \
-	qemu=/Applications/Q.app/Contents/MacOS/i386-softmmu.app/Contents/MacOS/i386-softmmu; \
+#	qemu=/Applications/Q.app/Contents/MacOS/i386-softmmu.app/Contents/MacOS/i386-softmmu; \
+	QEMU=/home/kchiu/packages/linux-x86_64/bin/qemu-system-i386; \
 	if test -x $$qemu; then echo $$qemu; exit; fi; fi; \
 	echo "***" 1>&2; \
 	echo "*** Error: Couldn't find a working QEMU executable." 1>&2; \
@@ -177,6 +179,9 @@
 	_usertests\
 	_wc\
 	_zombie\
+	_date\
+	_call100\
+	_cs550_user\
 
 fs.img: mkfs README $(UPROGS)
 	./mkfs fs.img README $(UPROGS)
Binary files xv6-cs550-2016,1s-p1-baseline/.nfs0000000360c3e51b00000158 and xv6-cs550-2016,1s-p2-working/.nfs0000000360c3e51b00000158 differ
diff -Nur xv6-cs550-2016,1s-p1-baseline/OS_proj2/defs.h xv6-cs550-2016,1s-p2-working/OS_proj2/defs.h
--- xv6-cs550-2016,1s-p1-baseline/OS_proj2/defs.h	1969-12-31 19:00:00.000000000 -0500
+++ xv6-cs550-2016,1s-p2-working/OS_proj2/defs.h	2016-03-08 22:51:50.000000000 -0500
@@ -0,0 +1,184 @@
+struct buf;
+struct context;
+struct file;
+struct inode;
+struct pipe;
+struct proc;
+struct rtcdate;
+struct spinlock;
+struct stat;
+struct superblock;
+
+// bio.c
+void            binit(void);
+struct buf*     bread(uint, uint);
+void            brelse(struct buf*);
+void            bwrite(struct buf*);
+
+// console.c
+void            consoleinit(void);
+void            cprintf(char*, ...);
+void            consoleintr(int(*)(void));
+void            panic(char*) __attribute__((noreturn));
+
+// exec.c
+int             exec(char*, char**);
+
+// file.c
+struct file*    filealloc(void);
+void            fileclose(struct file*);
+struct file*    filedup(struct file*);
+void            fileinit(void);
+int             fileread(struct file*, char*, int n);
+int             filestat(struct file*, struct stat*);
+int             filewrite(struct file*, char*, int n);
+
+// fs.c
+void            readsb(int dev, struct superblock *sb);
+int             dirlink(struct inode*, char*, uint);
+struct inode*   dirlookup(struct inode*, char*, uint*);
+struct inode*   ialloc(uint, short);
+struct inode*   idup(struct inode*);
+void            iinit(int dev);
+void            ilock(struct inode*);
+void            iput(struct inode*);
+void            iunlock(struct inode*);
+void            iunlockput(struct inode*);
+void            iupdate(struct inode*);
+int             namecmp(const char*, const char*);
+struct inode*   namei(char*);
+struct inode*   nameiparent(char*, char*);
+int             readi(struct inode*, char*, uint, uint);
+void            stati(struct inode*, struct stat*);
+int             writei(struct inode*, char*, uint, uint);
+
+// ide.c
+void            ideinit(void);
+void            ideintr(void);
+void            iderw(struct buf*);
+
+// ioapic.c
+void            ioapicenable(int irq, int cpu);
+extern uchar    ioapicid;
+void            ioapicinit(void);
+
+// kalloc.c
+char*           kalloc(void);
+void            kfree(char*);
+void            kinit1(void*, void*);
+void            kinit2(void*, void*);
+
+// kbd.c
+void            kbdintr(void);
+
+// lapic.c
+void            cmostime(struct rtcdate *r);
+int             cpunum(void);
+extern volatile uint*    lapic;
+void            lapiceoi(void);
+void            lapicinit(void);
+void            lapicstartap(uchar, uint);
+void            microdelay(int);
+
+// log.c
+void            initlog(int dev);
+void            log_write(struct buf*);
+void            begin_op();
+void            end_op();
+
+// mp.c
+extern int      ismp;
+int             mpbcpu(void);
+void            mpinit(void);
+void            mpstartthem(void);
+
+// picirq.c
+void            picenable(int);
+void            picinit(void);
+
+// pipe.c
+int             pipealloc(struct file**, struct file**);
+void            pipeclose(struct pipe*, int);
+int             piperead(struct pipe*, char*, int);
+int             pipewrite(struct pipe*, char*, int);
+
+//PAGEBREAK: 16
+// proc.c
+struct proc*    copyproc(struct proc*);
+void            exit(void);
+int             fork(void);
+int             growproc(int);
+int             kill(int);
+void            pinit(void);
+void            procdump(void);
+void            scheduler(void) __attribute__((noreturn));
+void            sched(void);
+void            sleep(void*, struct spinlock*);
+void            userinit(void);
+int             wait(void);
+void            wakeup(void*);
+void            yield(void);
+
+// swtch.S
+void            swtch(struct context**, struct context*);
+
+// spinlock.c
+void            acquire(struct spinlock*);
+void            getcallerpcs(void*, uint*);
+int             holding(struct spinlock*);
+void            initlock(struct spinlock*, char*);
+void            release(struct spinlock*);
+void            pushcli(void);
+void            popcli(void);
+
+// string.c
+int             memcmp(const void*, const void*, uint);
+void*           memmove(void*, const void*, uint);
+void*           memset(void*, int, uint);
+char*           safestrcpy(char*, const char*, int);
+int             strlen(const char*);
+int             strncmp(const char*, const char*, uint);
+char*           strncpy(char*, const char*, int);
+
+// syscall.c
+int             argint(int, int*);
+int             argptr(int, char**, int);
+int             argstr(int, char**);
+int             fetchint(uint, int*);
+int             fetchstr(uint, char**);
+void            syscall(void);
+void            syscall1(void);
+
+// timer.c
+void            timerinit(void);
+
+// trap.c
+void            idtinit(void);
+extern uint     ticks;
+void            tvinit(void);
+extern struct spinlock tickslock;
+
+// uart.c
+void            uartinit(void);
+void            uartintr(void);
+void            uartputc(int);
+
+// vm.c
+void            seginit(void);
+void            kvmalloc(void);
+void            vmenable(void);
+pde_t*          setupkvm(void);
+char*           uva2ka(pde_t*, char*);
+int             allocuvm(pde_t*, uint, uint);
+int             deallocuvm(pde_t*, uint, uint);
+void            freevm(pde_t*);
+void            inituvm(pde_t*, char*, uint);
+int             loaduvm(pde_t*, char*, struct inode*, uint, uint);
+pde_t*          copyuvm(pde_t*, uint);
+void            switchuvm(struct proc*);
+void            switchkvm(void);
+int             copyout(pde_t*, uint, void*, uint);
+void            clearpteu(pde_t *pgdir, char *uva);
+
+// number of elements in fixed-size array
+#define NELEM(x) (sizeof(x)/sizeof((x)[0]))
diff -Nur xv6-cs550-2016,1s-p1-baseline/OS_proj2/main.c xv6-cs550-2016,1s-p2-working/OS_proj2/main.c
--- xv6-cs550-2016,1s-p1-baseline/OS_proj2/main.c	1969-12-31 19:00:00.000000000 -0500
+++ xv6-cs550-2016,1s-p2-working/OS_proj2/main.c	2016-03-08 22:51:50.000000000 -0500
@@ -0,0 +1,118 @@
+#include "types.h"
+#include "defs.h"
+#include "param.h"
+#include "memlayout.h"
+#include "mmu.h"
+#include "proc.h"
+#include "x86.h"
+
+static void startothers(void);
+static void mpmain(void)  __attribute__((noreturn));
+extern pde_t *kpgdir;
+extern char end[]; // first address after kernel loaded from ELF file
+
+// Bootstrap processor starts running C code here.
+// Allocate a real stack and switch to it, first
+// doing some setup required for memory allocator to work.
+int
+main(void)
+{
+  kinit1(end, P2V(4*1024*1024)); // phys page allocator
+  kvmalloc();      // kernel page table
+  mpinit();        // collect info about this machine
+  lapicinit();
+  seginit();       // set up segments
+  cprintf("\ncpu%d: starting xv6\n\n", cpu->id);
+  picinit();       // interrupt controller
+  ioapicinit();    // another interrupt controller
+  consoleinit();   // I/O devices & their interrupts
+  uartinit();      // serial port
+  pinit();         // process table
+  tvinit();        // trap vectors
+  binit();         // buffer cache
+  fileinit();      // file table
+  ideinit();       // disk
+  if(!ismp)
+    timerinit();   // uniprocessor timer
+  startothers();   // start other processors
+  kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); // must come after startothers()
+  userinit();      // first user process
+  // Finish setting up this processor in mpmain.
+  mpmain();
+}
+
+// Other CPUs jump here from entryother.S.
+static void
+mpenter(void)
+{
+  switchkvm(); 
+  seginit();
+  lapicinit();
+  mpmain();
+}
+
+// Common CPU setup code.
+static void
+mpmain(void)
+{
+  cprintf("cpu%d: starting\n", cpu->id);
+  idtinit();       // load idt register
+  xchg(&cpu->started, 1); // tell startothers() we're up
+  scheduler();     // start running processes
+}
+
+pde_t entrypgdir[];  // For entry.S
+
+// Start the non-boot (AP) processors.
+static void
+startothers(void)
+{
+  extern uchar _binary_entryother_start[], _binary_entryother_size[];
+  uchar *code;
+  struct cpu *c;
+  char *stack;
+
+  // Write entry code to unused memory at 0x7000.
+  // The linker has placed the image of entryother.S in
+  // _binary_entryother_start.
+  code = p2v(0x7000);
+  memmove(code, _binary_entryother_start, (uint)_binary_entryother_size);
+
+  for(c = cpus; c < cpus+ncpu; c++){
+    if(c == cpus+cpunum())  // We've started already.
+      continue;
+
+    // Tell entryother.S what stack to use, where to enter, and what 
+    // pgdir to use. We cannot use kpgdir yet, because the AP processor
+    // is running in low  memory, so we use entrypgdir for the APs too.
+    stack = kalloc();
+    *(void**)(code-4) = stack + KSTACKSIZE;
+    *(void**)(code-8) = mpenter;
+    *(int**)(code-12) = (void *) v2p(entrypgdir);
+
+    lapicstartap(c->id, v2p(code));
+
+    // wait for cpu to finish mpmain()
+    while(c->started == 0)
+      ;
+  }
+}
+
+// Boot page table used in entry.S and entryother.S.
+// Page directories (and page tables), must start on a page boundary,
+// hence the "__aligned__" attribute.  
+// Use PTE_PS in page directory entry to enable 4Mbyte pages.
+__attribute__((__aligned__(PGSIZE)))
+pde_t entrypgdir[NPDENTRIES] = {
+  // Map VA's [0, 4MB) to PA's [0, 4MB)
+  [0] = (0) | PTE_P | PTE_W | PTE_PS,
+  // Map VA's [KERNBASE, KERNBASE+4MB) to PA's [0, 4MB)
+  [KERNBASE>>PDXSHIFT] = (0) | PTE_P | PTE_W | PTE_PS,
+};
+
+//PAGEBREAK!
+// Blank page.
+//PAGEBREAK!
+// Blank page.
+//PAGEBREAK!
+// Blank page.
diff -Nur xv6-cs550-2016,1s-p1-baseline/OS_proj2/Makefile xv6-cs550-2016,1s-p2-working/OS_proj2/Makefile
--- xv6-cs550-2016,1s-p1-baseline/OS_proj2/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ xv6-cs550-2016,1s-p2-working/OS_proj2/Makefile	2016-03-08 22:51:50.000000000 -0500
@@ -0,0 +1,287 @@
+OBJS = \
+	bio.o\
+	console.o\
+	exec.o\
+	file.o\
+	fs.o\
+	ide.o\
+	ioapic.o\
+	kalloc.o\
+	kbd.o\
+	lapic.o\
+	log.o\
+	main.o\
+	mp.o\
+	picirq.o\
+	pipe.o\
+	proc.o\
+	spinlock.o\
+	string.o\
+	swtch.o\
+	syscall.o\
+	sysfile.o\
+	sysproc.o\
+	timer.o\
+	trapasm.o\
+	trap.o\
+	uart.o\
+	vectors.o\
+	vm.o\
+	
+# Cross-compiling (e.g., on Mac OS X)
+# TOOLPREFIX = i386-jos-elf
+
+# Using native tools (e.g., on X86 Linux)
+#TOOLPREFIX = 
+
+# Try to infer the correct TOOLPREFIX if not set
+ifndef TOOLPREFIX
+TOOLPREFIX := $(shell if i386-jos-elf-objdump -i 2>&1 | grep '^elf32-i386$$' >/dev/null 2>&1; \
+	then echo 'i386-jos-elf-'; \
+	elif objdump -i 2>&1 | grep 'elf32-i386' >/dev/null 2>&1; \
+	then echo ''; \
+	else echo "***" 1>&2; \
+	echo "*** Error: Couldn't find an i386-*-elf version of GCC/binutils." 1>&2; \
+	echo "*** Is the directory with i386-jos-elf-gcc in your PATH?" 1>&2; \
+	echo "*** If your i386-*-elf toolchain is installed with a command" 1>&2; \
+	echo "*** prefix other than 'i386-jos-elf-', set your TOOLPREFIX" 1>&2; \
+	echo "*** environment variable to that prefix and run 'make' again." 1>&2; \
+	echo "*** To turn off this error, run 'gmake TOOLPREFIX= ...'." 1>&2; \
+	echo "***" 1>&2; exit 1; fi)
+endif
+
+# If the makefile can't find QEMU, specify its path here
+# QEMU = qemu-system-i386
+QEMU=/home/kchiu/packages/linux-x86_64/bin/qemu-system-i386
+
+# Try to infer the correct QEMU
+ifndef QEMU
+QEMU = $(shell if which qemu > /dev/null; \
+	then echo qemu; exit; \
+	elif which qemu-system-i386 > /dev/null; \
+	then echo qemu-system-i386; exit; \
+	else \
+#	qemu=/Applications/Q.app/Contents/MacOS/i386-softmmu.app/Contents/MacOS/i386-softmmu; \
+	QEMU=/home/kchiu/packages/linux-x86_64/bin/qemu-system-i386; \
+	if test -x $$qemu; then echo $$qemu; exit; fi; fi; \
+	echo "***" 1>&2; \
+	echo "*** Error: Couldn't find a working QEMU executable." 1>&2; \
+	echo "*** Is the directory containing the qemu binary in your PATH" 1>&2; \
+	echo "*** or have you tried setting the QEMU variable in Makefile?" 1>&2; \
+	echo "***" 1>&2; exit 1)
+endif
+
+CC = $(TOOLPREFIX)gcc
+AS = $(TOOLPREFIX)gas
+LD = $(TOOLPREFIX)ld
+OBJCOPY = $(TOOLPREFIX)objcopy
+OBJDUMP = $(TOOLPREFIX)objdump
+#CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer
+CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -fvar-tracking -fvar-tracking-assignments -O0 -g -Wall -MD -gdwarf-2 -m32 -Werror -fno-omit-frame-pointer
+CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
+ASFLAGS = -m32 -gdwarf-2 -Wa,-divide
+# FreeBSD ld wants ``elf_i386_fbsd''
+LDFLAGS += -m $(shell $(LD) -V | grep elf_i386 2>/dev/null)
+
+xv6.img: bootblock kernel fs.img
+	dd if=/dev/zero of=xv6.img count=10000
+	dd if=bootblock of=xv6.img conv=notrunc
+	dd if=kernel of=xv6.img seek=1 conv=notrunc
+
+xv6memfs.img: bootblock kernelmemfs
+	dd if=/dev/zero of=xv6memfs.img count=10000
+	dd if=bootblock of=xv6memfs.img conv=notrunc
+	dd if=kernelmemfs of=xv6memfs.img seek=1 conv=notrunc
+
+bootblock: bootasm.S bootmain.c
+	$(CC) $(CFLAGS) -fno-pic -O -nostdinc -I. -c bootmain.c
+	$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c bootasm.S
+	$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 -o bootblock.o bootasm.o bootmain.o
+	$(OBJDUMP) -S bootblock.o > bootblock.asm
+	$(OBJCOPY) -S -O binary -j .text bootblock.o bootblock
+	./sign.pl bootblock
+
+entryother: entryother.S
+	$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c entryother.S
+	$(LD) $(LDFLAGS) -N -e start -Ttext 0x7000 -o bootblockother.o entryother.o
+	$(OBJCOPY) -S -O binary -j .text bootblockother.o entryother
+	$(OBJDUMP) -S bootblockother.o > entryother.asm
+
+initcode: initcode.S
+	$(CC) $(CFLAGS) -nostdinc -I. -c initcode.S
+	$(LD) $(LDFLAGS) -N -e start -Ttext 0 -o initcode.out initcode.o
+	$(OBJCOPY) -S -O binary initcode.out initcode
+	$(OBJDUMP) -S initcode.o > initcode.asm
+
+kernel: $(OBJS) entry.o entryother initcode kernel.ld
+	$(LD) $(LDFLAGS) -T kernel.ld -o kernel entry.o $(OBJS) -b binary initcode entryother
+	$(OBJDUMP) -S kernel > kernel.asm
+	$(OBJDUMP) -t kernel | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > kernel.sym
+
+# kernelmemfs is a copy of kernel that maintains the
+# disk image in memory instead of writing to a disk.
+# This is not so useful for testing persistent storage or
+# exploring disk buffering implementations, but it is
+# great for testing the kernel on real hardware without
+# needing a scratch disk.
+MEMFSOBJS = $(filter-out ide.o,$(OBJS)) memide.o
+kernelmemfs: $(MEMFSOBJS) entry.o entryother initcode kernel.ld fs.img
+	$(LD) $(LDFLAGS) -T kernel.ld -o kernelmemfs entry.o  $(MEMFSOBJS) -b binary initcode entryother fs.img
+	$(OBJDUMP) -S kernelmemfs > kernelmemfs.asm
+	$(OBJDUMP) -t kernelmemfs | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > kernelmemfs.sym
+
+tags: $(OBJS) entryother.S _init
+	etags *.S *.c
+
+vectors.S: vectors.pl
+	perl vectors.pl > vectors.S
+
+ULIB = ulib.o usys.o printf.o umalloc.o
+
+# Override built-in so that we also get the assembly language.
+%.o: %.c
+	$(COMPILE.c) $(OUTPUT_OPTION) $<
+	$(COMPILE.c) -S $<
+
+_%: %.o $(ULIB)
+	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o $@ $^
+	$(OBJDUMP) -S $@ > $*.asm
+	$(OBJDUMP) -t $@ | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $*.sym
+
+_forktest: forktest.o $(ULIB)
+	# forktest has less library code linked in - needs to be small
+	# in order to be able to max out the proc table.
+	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o _forktest forktest.o ulib.o usys.o
+	$(OBJDUMP) -S _forktest > forktest.asm
+
+mkfs: mkfs.c fs.h
+	gcc -Werror -Wall -o mkfs mkfs.c
+
+# Prevent deletion of intermediate files, e.g. cat.o, after first build, so
+# that disk image changes after first build are persistent until clean.  More
+# details:
+# http://www.gnu.org/software/make/manual/html_node/Chained-Rules.html
+.PRECIOUS: %.o
+
+UPROGS=\
+	_cat\
+	_echo\
+	_forktest\
+	_grep\
+	_init\
+	_kill\
+	_ln\
+	_ls\
+	_mkdir\
+	_rm\
+	_sh\
+	_stressfs\
+	_usertests\
+	_wc\
+	_zombie\
+	_date\
+	_call100\
+	_cs550_user\
+
+fs.img: mkfs README $(UPROGS)
+	./mkfs fs.img README $(UPROGS)
+
+-include *.d
+
+clean: 
+	rm -f *.tex *.dvi *.idx *.aux *.log *.ind *.ilg \
+	*.o *.d *.s *.asm *.sym vectors.S bootblock entryother \
+	initcode initcode.out kernel xv6.img fs.img kernelmemfs mkfs \
+	.gdbinit \
+	$(UPROGS)
+
+# make a printout
+FILES = $(shell grep -v '^\#' runoff.list)
+PRINT = runoff.list runoff.spec README toc.hdr toc.ftr $(FILES)
+
+xv6.pdf: $(PRINT)
+	./runoff
+	ls -l xv6.pdf
+
+print: xv6.pdf
+
+# run in emulators
+
+bochs : fs.img xv6.img
+	if [ ! -e .bochsrc ]; then ln -s dot-bochsrc .bochsrc; fi
+	bochs -q
+
+# try to generate a unique GDB port
+GDBPORT = $(shell expr `id -u` % 5000 + 25000)
+# QEMU's gdb stub command line changed in 0.11
+QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \
+	then echo "-gdb tcp::$(GDBPORT)"; \
+	else echo "-s -p $(GDBPORT)"; fi)
+ifndef CPUS
+CPUS := 2
+endif
+QEMUOPTS = -hdb fs.img xv6.img -smp $(CPUS) -m 512 $(QEMUEXTRA)
+
+qemu: fs.img xv6.img
+	$(QEMU) -serial mon:stdio $(QEMUOPTS)
+
+qemu-memfs: xv6memfs.img
+	$(QEMU) xv6memfs.img -smp $(CPUS) -m 256
+
+qemu-nox: fs.img xv6.img
+	$(QEMU) -nographic $(QEMUOPTS)
+
+.gdbinit: .gdbinit.tmpl
+	sed "s/localhost:1234/localhost:$(GDBPORT)/" < $^ > $@
+
+qemu-gdb: fs.img xv6.img .gdbinit
+	@echo "*** Now run 'gdb'." 1>&2
+	$(QEMU) -serial mon:stdio $(QEMUOPTS) -S $(QEMUGDB)
+
+qemu-nox-gdb: fs.img xv6.img .gdbinit
+	@echo "*** Now run 'gdb'." 1>&2
+	$(QEMU) -nographic $(QEMUOPTS) -S $(QEMUGDB)
+
+# CUT HERE
+# prepare dist for students
+# after running make dist, probably want to
+# rename it to rev0 or rev1 or so on and then
+# check in that version.
+
+EXTRA=\
+	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
+	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\
+	printf.c umalloc.c\
+	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
+	.gdbinit.tmpl gdbutil\
+
+dist:
+	rm -rf dist
+	mkdir dist
+	for i in $(FILES); \
+	do \
+		grep -v PAGEBREAK $$i >dist/$$i; \
+	done
+	sed '/CUT HERE/,$$d' Makefile >dist/Makefile
+	echo >dist/runoff.spec
+	cp $(EXTRA) dist
+
+dist-test:
+	rm -rf dist
+	make dist
+	rm -rf dist-test
+	mkdir dist-test
+	cp dist/* dist-test
+	cd dist-test; $(MAKE) print
+	cd dist-test; $(MAKE) bochs || true
+	cd dist-test; $(MAKE) qemu
+
+# update this rule (change rev#) when it is time to
+# make a new revision.
+tar:
+	rm -rf /tmp/xv6
+	mkdir -p /tmp/xv6
+	cp dist/* dist/.gdbinit.tmpl /tmp/xv6
+	(cd /tmp; tar cf - xv6) | gzip >xv6-rev9.tar.gz  # the next one will be 9 (6/27/15)
+
+.PHONY: dist-test dist
diff -Nur xv6-cs550-2016,1s-p1-baseline/OS_proj2/syscall.c xv6-cs550-2016,1s-p2-working/OS_proj2/syscall.c
--- xv6-cs550-2016,1s-p1-baseline/OS_proj2/syscall.c	1969-12-31 19:00:00.000000000 -0500
+++ xv6-cs550-2016,1s-p2-working/OS_proj2/syscall.c	2016-03-08 22:51:50.000000000 -0500
@@ -0,0 +1,223 @@
+#include "types.h"
+#include "defs.h"
+#include "param.h"
+#include "memlayout.h"
+#include "mmu.h"
+#include "proc.h"
+#include "x86.h"
+#include "syscall.h"
+
+// User code makes a system call with INT T_SYSCALL.
+// System call number in %eax.
+// Arguments on the stack, from the user call to the C
+// library system call function. The saved user %esp points
+// to a saved program counter, and then the first argument.
+
+// Fetch the int at addr from the current process.
+int
+fetchint(uint addr, int *ip)
+{
+  if(addr >= proc->sz || addr+4 > proc->sz)
+    return -1;
+  *ip = *(int*)(addr);
+  return 0;
+}
+
+// Fetch the nul-terminated string at addr from the current process.
+// Doesn't actually copy the string - just sets *pp to point at it.
+// Returns length of string, not including nul.
+int
+fetchstr(uint addr, char **pp)
+{
+  char *s, *ep;
+
+  if(addr >= proc->sz)
+    return -1;
+  *pp = (char*)addr;
+  ep = (char*)proc->sz;
+  for(s = *pp; s < ep; s++)
+    if(*s == 0)
+      return s - *pp;
+  return -1;
+}
+
+// Fetch the nth 32-bit system call argument.
+int
+argint(int n, int *ip)
+{
+  return fetchint(proc->tf->esp + 4 + 4*n, ip);
+}
+
+// Fetch the nth word-sized system call argument as a pointer
+// to a block of memory of size n bytes.  Check that the pointer
+// lies within the process address space.
+int
+argptr(int n, char **pp, int size)
+{
+  int i;
+  
+  if(argint(n, &i) < 0)
+    return -1;
+  if((uint)i >= proc->sz || (uint)i+size > proc->sz)
+    return -1;
+  *pp = (char*)i;
+  return 0;
+}
+
+// Fetch the nth word-sized system call argument as a string pointer.
+// Check that the pointer is valid and the string is nul-terminated.
+// (There is no shared writable memory, so the string can't change
+// between this check and being used by the kernel.)
+int
+argstr(int n, char **pp)
+{
+  int addr;
+  if(argint(n, &addr) < 0)
+    return -1;
+  return fetchstr(addr, pp);
+}
+
+extern int sys_chdir(void);
+extern int sys_close(void);
+extern int sys_dup(void);
+extern int sys_exec(void);
+extern int sys_exit(void);
+extern int sys_fork(void);
+extern int sys_fstat(void);
+extern int sys_getpid(void);
+extern int sys_kill(void);
+extern int sys_link(void);
+extern int sys_mkdir(void);
+extern int sys_mknod(void);
+extern int sys_open(void);
+extern int sys_pipe(void);
+extern int sys_read(void);
+extern int sys_sbrk(void);
+extern int sys_sleep(void);
+extern int sys_unlink(void);
+extern int sys_wait(void);
+extern int sys_write(void);
+extern int sys_uptime(void);
+extern int sys_date(void);
+
+extern int sys_ls_call01(void);
+extern int sys_ls_call02(void);
+extern int sys_ls_call03(void);
+extern int sys_ls_call04(void);
+extern int sys_ls_call05(void);
+extern int sys_ls_call06(void);
+extern int sys_ls_call07(void);
+extern int sys_ls_call08(void);
+extern int sys_ls_call09(void);
+extern int sys_ls_call10(void);
+extern int sys_ls_call11(void);
+extern int sys_ls_call12(void);
+extern int sys_ls_call13(void);
+extern int sys_ls_call14(void);
+extern int sys_ls_call15(void);
+extern int sys_ls_call16(void);
+extern int sys_ls_call17(void);
+extern int sys_ls_call18(void);
+extern int sys_ls_call19(void);
+extern int sys_ls_call20(void);
+extern int sys_ls_call21(void);
+extern int sys_ls_call22(void);
+extern int sys_ls_call23(void);
+extern int sys_ls_call24(void);
+extern int sys_ls_call25(void);
+extern int sys_ls_call26(void);
+extern int sys_ls_call27(void);
+extern int sys_ls_call28(void);
+extern int sys_ls_call29(void);
+extern int sys_ls_call30(void);
+
+static int (*syscalls[])(void) = {
+[SYS_fork]    sys_fork,
+[SYS_exit]    sys_exit,
+[SYS_wait]    sys_wait,
+[SYS_pipe]    sys_pipe,
+[SYS_read]    sys_read,
+[SYS_kill]    sys_kill,
+[SYS_exec]    sys_exec,
+[SYS_fstat]   sys_fstat,
+[SYS_chdir]   sys_chdir,
+[SYS_dup]     sys_dup,
+[SYS_getpid]  sys_getpid,
+[SYS_sbrk]    sys_sbrk,
+[SYS_sleep]   sys_sleep,
+[SYS_uptime]  sys_uptime,
+[SYS_open]    sys_open,
+[SYS_write]   sys_write,
+[SYS_mknod]   sys_mknod,
+[SYS_unlink]  sys_unlink,
+[SYS_link]    sys_link,
+[SYS_mkdir]   sys_mkdir,
+[SYS_close]   sys_close,
+[SYS_date]    sys_date,
+};
+
+static int (*syscallls[])(void) = {
+sys_ls_call01,
+sys_ls_call02,
+sys_ls_call03,
+sys_ls_call04,
+sys_ls_call05,
+sys_ls_call06,
+sys_ls_call07,
+sys_ls_call08,
+sys_ls_call09,
+sys_ls_call10,
+sys_ls_call11,
+sys_ls_call12,
+sys_ls_call13,
+sys_ls_call14,
+sys_ls_call15,
+sys_ls_call16,
+sys_ls_call17,
+sys_ls_call18,
+sys_ls_call19,
+sys_ls_call20,
+sys_ls_call21,
+sys_ls_call22,
+sys_ls_call23,
+sys_ls_call24,
+sys_ls_call25,
+sys_ls_call26,
+sys_ls_call27,
+sys_ls_call28,
+sys_ls_call29,
+sys_ls_call30,
+};
+
+char lineartable[30][20] = {"ls_call01","ls_call02","ls_call03","ls_call04","ls_call05","ls_call06","ls_call07","ls_call08","ls_call09","ls_call10","ls_call11","ls_call12","ls_call13","ls_call14","ls_call15","ls_call16","ls_call17","ls_call18","ls_call19","ls_call20","ls_call21","ls_call22","ls_call23","ls_call24","ls_call25","ls_call26","ls_call27","ls_call28","ls_call29","ls_call30"};
+
+void
+syscall(void)
+{
+  int num;
+
+  num = proc->tf->eax;
+  if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
+    proc->tf->eax = syscalls[num]();
+  } else {
+    cprintf("%d %s: unknown sys call %d\n", proc->pid, proc->name, num);
+    proc->tf->eax = -1;
+  }
+}
+
+void
+syscall1(void)
+{
+
+  int p,i;
+  char *str1 = (char *) proc->tf->eax;
+  for(i=0;i<30;i++)
+  {
+    p = strncmp(str1,lineartable[i],strlen(str1));
+    if(p == 0)
+    {
+      proc->tf->eax = syscallls[i]();
+      break;
+    }
+  }
+}
diff -Nur xv6-cs550-2016,1s-p1-baseline/OS_proj2/syscall.h xv6-cs550-2016,1s-p2-working/OS_proj2/syscall.h
--- xv6-cs550-2016,1s-p1-baseline/OS_proj2/syscall.h	1969-12-31 19:00:00.000000000 -0500
+++ xv6-cs550-2016,1s-p2-working/OS_proj2/syscall.h	2016-03-08 22:51:50.000000000 -0500
@@ -0,0 +1,23 @@
+// System call numbers
+#define SYS_fork    1
+#define SYS_exit    2
+#define SYS_wait    3
+#define SYS_pipe    4
+#define SYS_read    5
+#define SYS_kill    6
+#define SYS_exec    7
+#define SYS_fstat   8
+#define SYS_chdir   9
+#define SYS_dup    10
+#define SYS_getpid 11
+#define SYS_sbrk   12
+#define SYS_sleep  13
+#define SYS_uptime 14
+#define SYS_open   15
+#define SYS_write  16
+#define SYS_mknod  17
+#define SYS_unlink 18
+#define SYS_link   19
+#define SYS_mkdir  20
+#define SYS_close  21
+#define SYS_date   22
diff -Nur xv6-cs550-2016,1s-p1-baseline/OS_proj2/trap.c xv6-cs550-2016,1s-p2-working/OS_proj2/trap.c
--- xv6-cs550-2016,1s-p1-baseline/OS_proj2/trap.c	1969-12-31 19:00:00.000000000 -0500
+++ xv6-cs550-2016,1s-p2-working/OS_proj2/trap.c	2016-03-08 22:51:50.000000000 -0500
@@ -0,0 +1,121 @@
+#include "types.h"
+#include "defs.h"
+#include "param.h"
+#include "memlayout.h"
+#include "mmu.h"
+#include "proc.h"
+#include "x86.h"
+#include "traps.h"
+#include "spinlock.h"
+
+// Interrupt descriptor table (shared by all CPUs).
+struct gatedesc idt[256];
+extern uint vectors[];  // in vectors.S: array of 256 entry pointers
+struct spinlock tickslock;
+uint ticks;
+
+void
+tvinit(void)
+{
+  int i;
+
+  for(i = 0; i < 256; i++)
+    SETGATE(idt[i], 0, SEG_KCODE<<3, vectors[i], 0);
+    SETGATE(idt[T_SYSCALL], 1, SEG_KCODE<<3, vectors[T_SYSCALL], DPL_USER);
+    SETGATE(idt[T_SYSCALL1], 1, SEG_KCODE<<3, vectors[T_SYSCALL1], DPL_USER); 
+    initlock(&tickslock, "time");
+}
+
+void
+idtinit(void)
+{
+  lidt(idt, sizeof(idt));
+}
+
+//PAGEBREAK: 41
+void
+trap(struct trapframe *tf)
+{
+  if(tf->trapno == T_SYSCALL){
+    if(proc->killed)
+      exit();
+    proc->tf = tf;
+    syscall();
+    if(proc->killed)
+      exit();
+    return;
+  }
+
+if(tf->trapno == T_SYSCALL1){
+    if(proc->killed)
+      exit();
+    proc->tf = tf;
+    syscall1();
+    if(proc->killed)
+      exit();
+    return;
+  }
+
+  switch(tf->trapno){
+  case T_IRQ0 + IRQ_TIMER:
+    if(cpu->id == 0){
+      acquire(&tickslock);
+      ticks++;
+      wakeup(&ticks);
+      release(&tickslock);
+    }
+    lapiceoi();
+    break;
+  case T_IRQ0 + IRQ_IDE:
+    ideintr();
+    lapiceoi();
+    break;
+  case T_IRQ0 + IRQ_IDE+1:
+    // Bochs generates spurious IDE1 interrupts.
+    break;
+  case T_IRQ0 + IRQ_KBD:
+    kbdintr();
+    lapiceoi();
+    break;
+  case T_IRQ0 + IRQ_COM1:
+    uartintr();
+    lapiceoi();
+    break;
+  case T_IRQ0 + 7:
+  case T_IRQ0 + IRQ_SPURIOUS:
+    cprintf("cpu%d: spurious interrupt at %x:%x\n",
+            cpu->id, tf->cs, tf->eip);
+    lapiceoi();
+    break;
+   
+  //PAGEBREAK: 13
+  default:
+    if(proc == 0 || (tf->cs&3) == 0){
+      // In kernel, it must be our mistake.
+      cprintf("unexpected trap %d from cpu %d eip %x (cr2=0x%x)\n",
+              tf->trapno, cpu->id, tf->eip, rcr2());
+      panic("trap");
+    }
+    // In user space, assume process misbehaved.
+    cprintf("pid %d %s: trap %d err %d on cpu %d "
+            "eip 0x%x addr 0x%x--kill proc\n",
+            proc->pid, proc->name, tf->trapno, tf->err, cpu->id, tf->eip, 
+            rcr2());
+    proc->killed = 1;
+  }
+
+  // Force process exit if it has been killed and is in user space.
+  // (If it is still executing in the kernel, let it keep running 
+  // until it gets to the regular system call return.)
+  if(proc && proc->killed && (tf->cs&3) == DPL_USER)
+    exit();
+
+  // Force process to give up CPU on clock tick.
+  // If interrupts were on while locks held, would need to check nlock.
+  if(proc && proc->state == RUNNING && tf->trapno == T_IRQ0+IRQ_TIMER)
+    yield();
+
+  // Check if the process has been killed since we yielded
+  if(proc && proc->killed && (tf->cs&3) == DPL_USER)
+    exit();
+}
diff -Nur xv6-cs550-2016,1s-p1-baseline/OS_proj2/traps.h xv6-cs550-2016,1s-p2-working/OS_proj2/traps.h
--- xv6-cs550-2016,1s-p1-baseline/OS_proj2/traps.h	1969-12-31 19:00:00.000000000 -0500
+++ xv6-cs550-2016,1s-p2-working/OS_proj2/traps.h	2016-03-08 22:51:50.000000000 -0500
@@ -0,0 +1,39 @@
+// x86 trap and interrupt constants.
+
+// Processor-defined:
+#define T_DIVIDE         0      // divide error
+#define T_DEBUG          1      // debug exception
+#define T_NMI            2      // non-maskable interrupt
+#define T_BRKPT          3      // breakpoint
+#define T_OFLOW          4      // overflow
+#define T_BOUND          5      // bounds check
+#define T_ILLOP          6      // illegal opcode
+#define T_DEVICE         7      // device not available
+#define T_DBLFLT         8      // double fault
+// #define T_COPROC      9      // reserved (not used since 486)
+#define T_TSS           10      // invalid task switch segment
+#define T_SEGNP         11      // segment not present
+#define T_STACK         12      // stack exception
+#define T_GPFLT         13      // general protection fault
+#define T_PGFLT         14      // page fault
+// #define T_RES        15      // reserved
+#define T_FPERR         16      // floating point error
+#define T_ALIGN         17      // aligment check
+#define T_MCHK          18      // machine check
+#define T_SIMDERR       19      // SIMD floating point error
+
+// These are arbitrarily chosen, but with care not to overlap
+// processor defined exceptions or interrupt vectors.
+#define T_SYSCALL       64      // system call
+#define T_DEFAULT      500      // catchall
+#define T_SYSCALL1      65      // system call
+
+#define T_IRQ0          32      // IRQ 0 corresponds to int T_IRQ
+
+#define IRQ_TIMER        0
+#define IRQ_KBD          1
+#define IRQ_COM1         4
+#define IRQ_IDE         14
+#define IRQ_ERROR       19
+#define IRQ_SPURIOUS    31
+
diff -Nur xv6-cs550-2016,1s-p1-baseline/OS_proj2/user.h xv6-cs550-2016,1s-p2-working/OS_proj2/user.h
--- xv6-cs550-2016,1s-p1-baseline/OS_proj2/user.h	1969-12-31 19:00:00.000000000 -0500
+++ xv6-cs550-2016,1s-p2-working/OS_proj2/user.h	2016-03-08 22:51:50.000000000 -0500
@@ -0,0 +1,71 @@
+struct stat;
+struct rtcdate;
+
+// system calls
+int fork(void);
+int exit(void) __attribute__((noreturn));
+int wait(void);
+int pipe(int*);
+int write(int, void*, int);
+int read(int, void*, int);
+int close(int);
+int kill(int);
+int exec(char*, char**);
+int open(char*, int);
+int mknod(char*, short, short);
+int unlink(char*);
+int fstat(int fd, struct stat*);
+int link(char*, char*);
+int mkdir(char*);
+int chdir(char*);
+int dup(int);
+int getpid(void);
+char* sbrk(int);
+int sleep(int);
+int uptime(void);
+
+int date(struct rtcdate *r);
+int ls_call01(void);
+int ls_call02(void);
+int ls_call03(void);
+int ls_call04(void);
+int ls_call05(void);
+int ls_call06(void);
+int ls_call07(void);
+int ls_call08(void);
+int ls_call09(void);
+int ls_call10(void);
+int ls_call11(void);
+int ls_call12(void);
+int ls_call13(void);
+int ls_call14(void);
+int ls_call15(void);
+int ls_call16(void);
+int ls_call17(void);
+int ls_call18(void);
+int ls_call19(void);
+int ls_call20(void);
+int ls_call21(void);
+int ls_call22(void);
+int ls_call23(void);
+int ls_call24(void);
+int ls_call25(void);
+int ls_call26(void);
+int ls_call27(void);
+int ls_call28(void);
+int ls_call29(void);
+int ls_call30(void);
+
+// ulib.c
+int stat(char*, struct stat*);
+char* strcpy(char*, char*);
+void *memmove(void*, void*, int);
+char* strchr(const char*, char c);
+int strcmp(const char*, const char*);
+void printf(int, char*, ...);
+char* gets(char*, int max);
+uint strlen(char*);
+void* memset(void*, int, uint);
+void* malloc(uint);
+void free(void*);
+int atoi(const char*);
diff -Nur xv6-cs550-2016,1s-p1-baseline/OS_proj2/usys.S xv6-cs550-2016,1s-p2-working/OS_proj2/usys.S
--- xv6-cs550-2016,1s-p1-baseline/OS_proj2/usys.S	1969-12-31 19:00:00.000000000 -0500
+++ xv6-cs550-2016,1s-p2-working/OS_proj2/usys.S	2016-03-08 22:51:50.000000000 -0500
@@ -0,0 +1,161 @@
+#include "syscall.h"
+#include "traps.h"
+
+#define SYSCALL(name) \
+  .globl name; \
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+#define SYSCALL1(name) \
+  .globl name; \
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL1; \
+    ret
+
+SYS_ls_call01:
+        .string "ls_call01"
+
+SYS_ls_call02:
+        .string "ls_call02"
+
+SYS_ls_call03:
+      	.string "ls_call03"
+
+SYS_ls_call04:
+        .string "ls_call04"
+
+SYS_ls_call05:
+        .string "ls_call05"
+
+SYS_ls_call06:
+        .string "ls_call06"  
+
+SYS_ls_call07:
+      	.string "ls_call07"
+
+SYS_ls_call08:
+        .string "ls_call08"
+
+SYS_ls_call09:
+        .string "ls_call09"
+
+SYS_ls_call10:
+        .string "ls_call10" 
+
+SYS_ls_call11:
+        .string "ls_call11"
+
+SYS_ls_call12:
+        .string "ls_call12"
+
+SYS_ls_call13:
+      	.string "ls_call13"
+
+SYS_ls_call14:
+        .string "ls_call14"
+
+SYS_ls_call15:
+        .string "ls_call15"
+
+SYS_ls_call16:
+        .string "ls_call16"  
+
+SYS_ls_call17:
+      	.string "ls_call17"
+
+SYS_ls_call18:
+        .string "ls_call18"
+
+SYS_ls_call19:
+        .string "ls_call19"
+
+SYS_ls_call20:
+        .string "ls_call20" 
+
+SYS_ls_call21:
+        .string "ls_call21"
+
+SYS_ls_call22:
+        .string "ls_call22"
+
+SYS_ls_call23:
+      	.string "ls_call23"
+
+SYS_ls_call24:
+        .string "ls_call24"
+
+SYS_ls_call25:
+        .string "ls_call25"
+
+SYS_ls_call26:
+        .string "ls_call26"  
+
+SYS_ls_call27:
+      	.string "ls_call27"
+
+SYS_ls_call28:
+        .string "ls_call28"
+
+SYS_ls_call29:
+        .string "ls_call29"
+
+SYS_ls_call30:
+        .string "ls_call30" 
+
+SYSCALL(fork)
+SYSCALL(exit)
+SYSCALL(wait)
+SYSCALL(pipe)
+SYSCALL(read)
+SYSCALL(write)
+SYSCALL(close)
+SYSCALL(kill)
+SYSCALL(exec)
+SYSCALL(open)
+SYSCALL(mknod)
+SYSCALL(unlink)
+SYSCALL(fstat)
+SYSCALL(link)
+SYSCALL(mkdir)
+SYSCALL(chdir)
+SYSCALL(dup)
+SYSCALL(getpid)
+SYSCALL(sbrk)
+SYSCALL(sleep)
+SYSCALL(uptime)
+SYSCALL(date)
+
+SYSCALL1(ls_call01)
+SYSCALL1(ls_call02)
+SYSCALL1(ls_call03)
+SYSCALL1(ls_call04)
+SYSCALL1(ls_call05)
+SYSCALL1(ls_call06)
+SYSCALL1(ls_call07)
+SYSCALL1(ls_call08)
+SYSCALL1(ls_call09)
+SYSCALL1(ls_call10)
+SYSCALL1(ls_call11)
+SYSCALL1(ls_call12)
+SYSCALL1(ls_call13)
+SYSCALL1(ls_call14)
+SYSCALL1(ls_call15)
+SYSCALL1(ls_call16)
+SYSCALL1(ls_call17)
+SYSCALL1(ls_call18)
+SYSCALL1(ls_call19)
+SYSCALL1(ls_call20)
+SYSCALL1(ls_call21)
+SYSCALL1(ls_call22)
+SYSCALL1(ls_call23)
+SYSCALL1(ls_call24)
+SYSCALL1(ls_call25)
+SYSCALL1(ls_call26)
+SYSCALL1(ls_call27)
+SYSCALL1(ls_call28)
+SYSCALL1(ls_call29)
+SYSCALL1(ls_call30)
+
Binary files xv6-cs550-2016,1s-p1-baseline/OS_proj2.tar and xv6-cs550-2016,1s-p2-working/OS_proj2.tar differ
diff -Nur xv6-cs550-2016,1s-p1-baseline/syscall.c xv6-cs550-2016,1s-p2-working/syscall.c
--- xv6-cs550-2016,1s-p1-baseline/syscall.c	2016-02-11 21:48:16.000000000 -0500
+++ xv6-cs550-2016,1s-p2-working/syscall.c	2016-03-08 22:50:10.000000000 -0500
@@ -98,6 +98,38 @@
 extern int sys_wait(void);
 extern int sys_write(void);
 extern int sys_uptime(void);
+extern int sys_date(void);
+
+extern int sys_ls_call01(void);
+extern int sys_ls_call02(void);
+extern int sys_ls_call03(void);
+extern int sys_ls_call04(void);
+extern int sys_ls_call05(void);
+extern int sys_ls_call06(void);
+extern int sys_ls_call07(void);
+extern int sys_ls_call08(void);
+extern int sys_ls_call09(void);
+extern int sys_ls_call10(void);
+extern int sys_ls_call11(void);
+extern int sys_ls_call12(void);
+extern int sys_ls_call13(void);
+extern int sys_ls_call14(void);
+extern int sys_ls_call15(void);
+extern int sys_ls_call16(void);
+extern int sys_ls_call17(void);
+extern int sys_ls_call18(void);
+extern int sys_ls_call19(void);
+extern int sys_ls_call20(void);
+extern int sys_ls_call21(void);
+extern int sys_ls_call22(void);
+extern int sys_ls_call23(void);
+extern int sys_ls_call24(void);
+extern int sys_ls_call25(void);
+extern int sys_ls_call26(void);
+extern int sys_ls_call27(void);
+extern int sys_ls_call28(void);
+extern int sys_ls_call29(void);
+extern int sys_ls_call30(void);
 
 static int (*syscalls[])(void) = {
 [SYS_fork]    sys_fork,
@@ -121,8 +153,44 @@
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_date]    sys_date,
+};
+
+static int (*syscallls[])(void) = {
+sys_ls_call01,
+sys_ls_call02,
+sys_ls_call03,
+sys_ls_call04,
+sys_ls_call05,
+sys_ls_call06,
+sys_ls_call07,
+sys_ls_call08,
+sys_ls_call09,
+sys_ls_call10,
+sys_ls_call11,
+sys_ls_call12,
+sys_ls_call13,
+sys_ls_call14,
+sys_ls_call15,
+sys_ls_call16,
+sys_ls_call17,
+sys_ls_call18,
+sys_ls_call19,
+sys_ls_call20,
+sys_ls_call21,
+sys_ls_call22,
+sys_ls_call23,
+sys_ls_call24,
+sys_ls_call25,
+sys_ls_call26,
+sys_ls_call27,
+sys_ls_call28,
+sys_ls_call29,
+sys_ls_call30,
 };
 
+char lineartable[30][20] = {"ls_call01","ls_call02","ls_call03","ls_call04","ls_call05","ls_call06","ls_call07","ls_call08","ls_call09","ls_call10","ls_call11","ls_call12","ls_call13","ls_call14","ls_call15","ls_call16","ls_call17","ls_call18","ls_call19","ls_call20","ls_call21","ls_call22","ls_call23","ls_call24","ls_call25","ls_call26","ls_call27","ls_call28","ls_call29","ls_call30"};
+
 void
 syscall(void)
 {
@@ -132,8 +200,24 @@
   if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
     proc->tf->eax = syscalls[num]();
   } else {
-    cprintf("%d %s: unknown sys call %d\n",
-            proc->pid, proc->name, num);
+    cprintf("%d %s: unknown sys call %d\n", proc->pid, proc->name, num);
     proc->tf->eax = -1;
   }
 }
+
+void
+syscall1(void)
+{
+
+  int p,i;
+  char *str1 = (char *) proc->tf->eax;
+  for(i=0;i<30;i++)
+  {
+    p = strncmp(str1,lineartable[i],strlen(str1));
+    if(p == 0)
+    {
+      proc->tf->eax = syscallls[i]();
+      break;
+    }
+  }
+}
diff -Nur xv6-cs550-2016,1s-p1-baseline/syscall.h xv6-cs550-2016,1s-p2-working/syscall.h
--- xv6-cs550-2016,1s-p1-baseline/syscall.h	2016-02-11 21:48:16.000000000 -0500
+++ xv6-cs550-2016,1s-p2-working/syscall.h	2016-03-08 20:34:46.000000000 -0500
@@ -20,3 +20,4 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_date   22
diff -Nur xv6-cs550-2016,1s-p1-baseline/sysproc.c xv6-cs550-2016,1s-p2-working/sysproc.c
--- xv6-cs550-2016,1s-p1-baseline/sysproc.c	2016-02-11 21:48:16.000000000 -0500
+++ xv6-cs550-2016,1s-p2-working/sysproc.c	2016-03-08 19:32:48.000000000 -0500
@@ -83,9 +83,169 @@
 sys_uptime(void)
 {
   uint xticks;
-  
+
   acquire(&tickslock);
   xticks = ticks;
   release(&tickslock);
   return xticks;
 }
+
+int
+sys_date(void)
+{
+  struct rtcdate *r;
+  if (argptr(0, (void*)&r, sizeof(struct rtcdate)) < 0)
+    return -1;
+  cmostime(r);
+  return 0;
+}
+
+int sys_ls_call01(void)
+{
+  return 1;
+}
+
+int sys_ls_call02(void)
+{
+  return 2;
+}
+
+int sys_ls_call03(void)
+{
+  return 3;
+}
+
+int sys_ls_call04(void)
+{
+  return 4;
+}
+
+int sys_ls_call05(void)
+{
+  return 5;
+}
+
+int sys_ls_call06(void)
+{
+  return 6;
+}
+
+int sys_ls_call07(void)
+{
+  return 7;
+}
+
+int sys_ls_call08(void)
+{
+  return 8;
+}
+
+int sys_ls_call09(void)
+{
+  return 9;
+}
+
+int sys_ls_call10(void)
+{
+  return 10;
+}
+
+int sys_ls_call11(void)
+{
+  return 11;
+}
+
+int sys_ls_call12(void)
+{
+  return 12;
+}
+
+int sys_ls_call13(void)
+{
+  return 13;
+}
+
+int sys_ls_call14(void)
+{
+  return 14;
+}
+
+int sys_ls_call15(void)
+{
+  return 15;
+}
+
+int sys_ls_call16(void)
+{
+  return 16;
+}
+
+int sys_ls_call17(void)
+{
+  return 17;
+}
+
+int sys_ls_call18(void)
+{
+  return 18;
+}
+
+int sys_ls_call19(void)
+{
+  return 19;
+}
+
+int sys_ls_call20(void)
+{
+  return 20;
+}
+
+int sys_ls_call21(void)
+{
+  return 21;
+}
+
+int sys_ls_call22(void)
+{
+  return 22;
+}
+
+int sys_ls_call23(void)
+{
+  return 23;
+}
+
+int sys_ls_call24(void)
+{
+  return 24;
+}
+
+int sys_ls_call25(void)
+{
+  return 25;
+}
+
+int sys_ls_call26(void)
+{
+  return 26;
+}
+
+int sys_ls_call27(void)
+{
+  return 27;
+}
+
+int sys_ls_call28(void)
+{
+  return 28;
+}
+
+int sys_ls_call29(void)
+{
+  return 29;
+}
+
+int sys_ls_call30(void)
+{
+  return 30;
+}
diff -Nur xv6-cs550-2016,1s-p1-baseline/sysproc.c.save.1 xv6-cs550-2016,1s-p2-working/sysproc.c.save.1
--- xv6-cs550-2016,1s-p1-baseline/sysproc.c.save.1	1969-12-31 19:00:00.000000000 -0500
+++ xv6-cs550-2016,1s-p2-working/sysproc.c.save.1	2016-03-04 19:40:00.000000000 -0500
@@ -0,0 +1,102 @@
+#include "types.h"
+#include "x86.h"
+#include "defs.h"
+#include "date.h"
+#include "param.h"
+#include "memlayout.h"
+#include "mmu.h"
+#include "proc.h"
+
+int
+sys_fork(void)
+{
+  return fork();
+}
+
+int
+sys_exit(void)
+{
+  exit();
+  return 0;  // not reached
+}
+
+int
+sys_wait(void)
+{
+  return wait();
+}
+
+int
+sys_kill(void)
+{
+  int pid;
+
+  if(argint(0, &pid) < 0)
+    return -1;
+  return kill(pid);
+}
+
+int
+sys_getpid(void)
+{
+  return proc->pid;
+}
+
+int
+sys_sbrk(void)
+{
+  int addr;
+  int n;
+
+  if(argint(0, &n) < 0)
+    return -1;
+  addr = proc->sz;
+  if(growproc(n) < 0)
+    return -1;
+  return addr;
+}
+
+int
+sys_sleep(void)
+{
+  int n;
+  uint ticks0;
+
+  if(argint(0, &n) < 0)
+    return -1;
+  acquire(&tickslock);
+  ticks0 = ticks;
+  while(ticks - ticks0 < n){
+    if(proc->killed){
+      release(&tickslock);
+      return -1;
+    }
+    sleep(&ticks, &tickslock);
+  }
+  release(&tickslock);
+  return 0;
+}
+
+// return how many clock tick interrupts have occurred
+// since start.
+int
+sys_uptime(void)
+{
+  uint xticks;
+
+  acquire(&tickslock);
+  xticks = ticks;
+  release(&tickslock);
+  return xticks;
+}
+
+int
+sys_date(void)
+{
+  struct rtcdate *r;
+  if (argptr(0, (void*)&r, sizeof(struct rtcdate)) < 0)
+    return -1;
+  cmostime(r);
+  return 0;
+}
+
diff -Nur xv6-cs550-2016,1s-p1-baseline/trap.c xv6-cs550-2016,1s-p2-working/trap.c
--- xv6-cs550-2016,1s-p1-baseline/trap.c	2016-02-11 21:48:16.000000000 -0500
+++ xv6-cs550-2016,1s-p2-working/trap.c	2016-03-08 20:46:33.000000000 -0500
@@ -21,9 +21,9 @@
 
   for(i = 0; i < 256; i++)
     SETGATE(idt[i], 0, SEG_KCODE<<3, vectors[i], 0);
-  SETGATE(idt[T_SYSCALL], 1, SEG_KCODE<<3, vectors[T_SYSCALL], DPL_USER);
-  
-  initlock(&tickslock, "time");
+    SETGATE(idt[T_SYSCALL], 1, SEG_KCODE<<3, vectors[T_SYSCALL], DPL_USER);
+    SETGATE(idt[T_SYSCALL1], 1, SEG_KCODE<<3, vectors[T_SYSCALL1], DPL_USER); 
+    initlock(&tickslock, "time");
 }
 
 void
@@ -44,6 +44,16 @@
     if(proc->killed)
       exit();
     return;
+  }
+
+if(tf->trapno == T_SYSCALL1){
+    if(proc->killed)
+      exit();
+    proc->tf = tf;
+    syscall1();
+    if(proc->killed)
+      exit();
+    return;
   }
 
   switch(tf->trapno){
diff -Nur xv6-cs550-2016,1s-p1-baseline/traps.h xv6-cs550-2016,1s-p2-working/traps.h
--- xv6-cs550-2016,1s-p1-baseline/traps.h	2016-02-11 21:48:16.000000000 -0500
+++ xv6-cs550-2016,1s-p2-working/traps.h	2016-03-08 20:46:41.000000000 -0500
@@ -26,6 +26,7 @@
 // processor defined exceptions or interrupt vectors.
 #define T_SYSCALL       64      // system call
 #define T_DEFAULT      500      // catchall
+#define T_SYSCALL1      65      // system call
 
 #define T_IRQ0          32      // IRQ 0 corresponds to int T_IRQ
 
diff -Nur xv6-cs550-2016,1s-p1-baseline/user.h xv6-cs550-2016,1s-p2-working/user.h
--- xv6-cs550-2016,1s-p1-baseline/user.h	2016-02-11 21:48:16.000000000 -0500
+++ xv6-cs550-2016,1s-p2-working/user.h	2016-03-08 20:50:12.000000000 -0500
@@ -24,6 +24,38 @@
 int sleep(int);
 int uptime(void);
 
+int date(struct rtcdate *r);
+int ls_call01(void);
+int ls_call02(void);
+int ls_call03(void);
+int ls_call04(void);
+int ls_call05(void);
+int ls_call06(void);
+int ls_call07(void);
+int ls_call08(void);
+int ls_call09(void);
+int ls_call10(void);
+int ls_call11(void);
+int ls_call12(void);
+int ls_call13(void);
+int ls_call14(void);
+int ls_call15(void);
+int ls_call16(void);
+int ls_call17(void);
+int ls_call18(void);
+int ls_call19(void);
+int ls_call20(void);
+int ls_call21(void);
+int ls_call22(void);
+int ls_call23(void);
+int ls_call24(void);
+int ls_call25(void);
+int ls_call26(void);
+int ls_call27(void);
+int ls_call28(void);
+int ls_call29(void);
+int ls_call30(void);
+
 // ulib.c
 int stat(char*, struct stat*);
 char* strcpy(char*, char*);
diff -Nur xv6-cs550-2016,1s-p1-baseline/usys.S xv6-cs550-2016,1s-p2-working/usys.S
--- xv6-cs550-2016,1s-p1-baseline/usys.S	2016-02-11 21:48:16.000000000 -0500
+++ xv6-cs550-2016,1s-p2-working/usys.S	2016-03-08 20:52:01.000000000 -0500
@@ -8,6 +8,103 @@
     int $T_SYSCALL; \
     ret
 
+#define SYSCALL1(name) \
+  .globl name; \
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL1; \
+    ret
+
+SYS_ls_call01:
+        .string "ls_call01"
+
+SYS_ls_call02:
+        .string "ls_call02"
+
+SYS_ls_call03:
+      	.string "ls_call03"
+
+SYS_ls_call04:
+        .string "ls_call04"
+
+SYS_ls_call05:
+        .string "ls_call05"
+
+SYS_ls_call06:
+        .string "ls_call06"  
+
+SYS_ls_call07:
+      	.string "ls_call07"
+
+SYS_ls_call08:
+        .string "ls_call08"
+
+SYS_ls_call09:
+        .string "ls_call09"
+
+SYS_ls_call10:
+        .string "ls_call10" 
+
+SYS_ls_call11:
+        .string "ls_call11"
+
+SYS_ls_call12:
+        .string "ls_call12"
+
+SYS_ls_call13:
+      	.string "ls_call13"
+
+SYS_ls_call14:
+        .string "ls_call14"
+
+SYS_ls_call15:
+        .string "ls_call15"
+
+SYS_ls_call16:
+        .string "ls_call16"  
+
+SYS_ls_call17:
+      	.string "ls_call17"
+
+SYS_ls_call18:
+        .string "ls_call18"
+
+SYS_ls_call19:
+        .string "ls_call19"
+
+SYS_ls_call20:
+        .string "ls_call20" 
+
+SYS_ls_call21:
+        .string "ls_call21"
+
+SYS_ls_call22:
+        .string "ls_call22"
+
+SYS_ls_call23:
+      	.string "ls_call23"
+
+SYS_ls_call24:
+        .string "ls_call24"
+
+SYS_ls_call25:
+        .string "ls_call25"
+
+SYS_ls_call26:
+        .string "ls_call26"  
+
+SYS_ls_call27:
+      	.string "ls_call27"
+
+SYS_ls_call28:
+        .string "ls_call28"
+
+SYS_ls_call29:
+        .string "ls_call29"
+
+SYS_ls_call30:
+        .string "ls_call30" 
+
 SYSCALL(fork)
 SYSCALL(exit)
 SYSCALL(wait)
@@ -29,3 +126,36 @@
 SYSCALL(sbrk)
 SYSCALL(sleep)
 SYSCALL(uptime)
+SYSCALL(date)
+
+SYSCALL1(ls_call01)
+SYSCALL1(ls_call02)
+SYSCALL1(ls_call03)
+SYSCALL1(ls_call04)
+SYSCALL1(ls_call05)
+SYSCALL1(ls_call06)
+SYSCALL1(ls_call07)
+SYSCALL1(ls_call08)
+SYSCALL1(ls_call09)
+SYSCALL1(ls_call10)
+SYSCALL1(ls_call11)
+SYSCALL1(ls_call12)
+SYSCALL1(ls_call13)
+SYSCALL1(ls_call14)
+SYSCALL1(ls_call15)
+SYSCALL1(ls_call16)
+SYSCALL1(ls_call17)
+SYSCALL1(ls_call18)
+SYSCALL1(ls_call19)
+SYSCALL1(ls_call20)
+SYSCALL1(ls_call21)
+SYSCALL1(ls_call22)
+SYSCALL1(ls_call23)
+SYSCALL1(ls_call24)
+SYSCALL1(ls_call25)
+SYSCALL1(ls_call26)
+SYSCALL1(ls_call27)
+SYSCALL1(ls_call28)
+SYSCALL1(ls_call29)
+SYSCALL1(ls_call30)
+
